# 视频合成工作流程文档

本文档详细描述了在获取所有必需的素材、音频和字幕文件后，系统如何将这些元素合成为最终视频的全过程。

## 概述

视频合成的目标是将一系列独立的视频片段（segments）、配音音频（audio）和字幕文件（SRT）组合成一个完整的、带字幕的最终视频。整个流程通过 `src/core/video_composer.py` 中的 `VideoComposer` 类进行管理，并由 `src/logic/video_composer_logic.py` 中的 `VideoCompositionLogic` 进行调用。流程被划分为几个独立的、可分步执行的阶段，以便于调试和管理。

## 核心组件

-   **`VideoCompositionLogic`**: 高级流程编排器，负责调用 `VideoComposer` 的各个方法来执行合成的特定阶段（例如，只合成无声视频，或完成完整合成）。
-   **`VideoComposer`**: 核心合成器，直接封装了所有与 `ffmpeg` 相关的命令行调用，负责执行实际的视频处理任务。

## 工作流程详解

视频合成过程遵循以下四个主要阶段：

### 第1阶段：准备与规格化 (Prepare and Normalize)

-   **方法**: `prepare_and_normalize_all_segments()`
-   **目标**: 将所有来源不同、规格各异的原始视频素材处理成符合最终视频要求的、统一规格的临时视频片段。

**具体步骤**:
1.  **遍历子场景**: 程序会遍历 `final_scenes_assets.json` 中定义的每一个子场景（sub-scene）。
2.  **时长处理**: 根据场景所需时长（`required_duration`），对原始视频进行裁剪（如果原始视频过长）或延长（如果原始视频过短，当前通过循环播放实现）。
3.  **视频规格化 (Normalization)**: 这是最关键的一步，通过 `ffmpeg` 的 `-vf` (video filter) 参数链实现：
    -   **缩放与填充 (`scale` & `pad`)**: 使用 `scale=W:H:force_original_aspect_ratio=decrease` 和 `pad=W:H:-1:-1` 的组合滤镜。这个组合能一步到位地将视频**等比缩放**以完全适应目标画布（例如 `1920x1080`），并在必要时自动用黑边填充剩余空间（Letterboxing 或 Pillarboxing）。这是处理各种尺寸视频的最稳健方法。
    -   **帧率统一 (`fps`)**: 将视频的帧率统一为项目配置的帧率（例如 `30`）。
4.  **路径处理**: 所有传递给 `ffmpeg` 的文件路径都会被转换为使用正斜杠 `/` 的格式，以确保命令在 Windows、Linux 和 macOS 上的兼容性。
5.  **编码与输出**: 每个处理后的视频片段都会被重新编码，并保存为一个临时的 `.mp4` 文件（例如 `seg_001.mp4`）。此步骤会优先尝试使用硬件加速编码器（如 NVIDIA NVENC），如果失败，则会自动回退到软件编码器（`libx264`）。

### 第2阶段：拼接 (Concatenate)

-   **方法**: `concatenate_segments()`
-   **目标**: 将所有经过规格化的独立视频片段按顺序拼接成一个完整的、但没有声音的视频。

**具体步骤**:
1.  **创建拼接列表**: 程序会生成一个 `concat_list.txt` 文件，其中包含了所有待拼接片段的文件路径。
2.  **执行拼接**: 调用 `ffmpeg` 的 `concat` demuxer，它会读取这个列表文件，并将所有视频片段按顺序合并成一个单一的视频文件 (`silent_video.mp4`)。这个过程使用 `copy` 编解码器，因此速度非常快，因为它只复制视频流而不进行重新编码。

### 第3阶段：音频合并 (Merge Audio)

-   **方法**: `merge_audio()`
-   **目标**: 将在之前步骤中生成的配音文件（`final_audio.wav`）合并到无声的拼接视频中。

**具体步骤**:
1.  **合并音视频**: 调用 `ffmpeg`，将 `silent_video.mp4` 作为视频输入，`final_audio.wav` 作为音频输入。
2.  **流映射 (`map`)**: 使用 `-map` 参数，明确地从视频输入中选取视频流（`0:v:0`），从音频输入中选取音频流（`1:a:0`）。
3.  **时长对齐 (`-t`)**: 以音频文件的时长为基准，确保最终输出的视频时长与配音完全一致。
4.  **输出**: 生成一个包含视频和音频的文件 (`video_with_audio.mp4`)。

### 第4阶段：字幕烧录 (Burn Subtitles)

-   **方法**: `burn_subtitles_to_video()`
-   **目标**: 将字幕文件（`final_srt`）的内容永久性地嵌入到视频画面中。

**具体步骤**:
1.  **调用字幕滤镜**: 使用 `ffmpeg` 的 `-vf` 参数和 `subtitles` 滤镜。
2.  **指定字幕文件**: 滤镜会读取指定的 `.srt` 字幕文件。
3.  **样式化**: `VideoComposer` 会从 `config.yaml` 中读取字体、大小、颜色等样式配置，并将它们传递给 `subtitles` 滤镜的 `force_style` 选项，以确保字幕按预设的样式显示。
4.  **输出最终视频**: 生成最终的成品视频文件 (`final_video.mp4`)。

## 错误处理

根据“不允许带病运行”的设计原则，视频合成流程采取了严格的错误处理策略：

-   在处理视频片段时，如果首选的硬件编码器失败，系统会尝试一次使用软件编码器作为备用方案。
-   如果软件编码器**也失败了**，或者在流程中任何其他 `ffmpeg` 命令执行失败（返回非零退出码），程序都会捕获 `CalledProcessError` 异常，记录详细的错误日志，然后**立即重新抛出异常**。
-   这个未被处理的异常会沿着调用栈向上传播，最终导致整个合成任务**立即中止**，从而防止产生错误的或不完整的视频输出，并确保错误能够被上层调度系统清晰地捕获。
